<!doctype html>
<html lang="lv">
<head>
  <link rel="icon" href="data:,">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DÄ«Ä·a hokeja lÄ«ga â€” Sesijas</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; max-width: 1200px; }
    h1 { margin: 0 0 10px; }
    h2 { margin: 0 0 10px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 12px; margin: 12px 0; }
    label { display:block; font-size: 12px; opacity: .8; margin-bottom: 4px; }
    input, select, button, textarea { padding: 8px; border-radius: 10px; border: 1px solid #ccc; }
    button { cursor:pointer; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    .muted { opacity: .7; font-size: 12px; }
    .pill { display:inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; margin: 2px 4px 2px 0; }
    .danger { border-color: #ffb3b3; background:#fff5f5; }
    .ok { border-color: #b8f0c2; background:#f5fff7; }
    .grid { display:grid; gap:10px; }
    @media (min-width: 920px) {
      .grid-2 { grid-template-columns: 1fr 1fr; }
      .grid-3 { grid-template-columns: 1fr 1fr 1fr; }
    }
    .btn-sm { padding: 6px 10px; font-size: 12px; border-radius: 999px; }
    .btn-ghost { background: #fff; }
    .btn-primary { background: #111; color: #fff; border-color:#111; }
    .btn-primary:hover { opacity:.9; }
    .btn-ghost:hover { background:#fafafa; }
    .warn { border-color:#ffd7a3; background:#fff9f0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>ğŸ’ DÄ«Ä·a hokeja lÄ«ga</h1>
  <div class="muted">
    Modelis: <b>Sesija</b> = ieraÅ¡anÄs (tavs â€œmaÄu skaits sezonÄâ€). <b>Raundi</b> ir pÄ“c izvÄ“les (uzvaras + ELO + G/A).
    Viss glabÄjas tavÄ pÄrlÅ«kÄ (LocalStorage). Vari eksportÄ“t/importÄ“t JSON.
  </div>

  <div class="card">
    <h2>1) SpÄ“lÄ“tÄji</h2>
    <div class="row">
      <div>
        <label>Jauns spÄ“lÄ“tÄjs</label>
        <input id="playerName" placeholder="piem. JÄnis" />
      </div>
      <button id="addPlayer" class="btn-primary">Pievienot</button>
      <button id="resetAll" class="danger">NotÄ«rÄ«t visu sezonu</button>
    </div>
    <div class="muted" style="margin-top:6px;">Tip: pievieno ~30 spÄ“lÄ“tÄjus. DzÄ“st var tikai tos, kas nav izmantoti sesijÄs.</div>
    <div id="playerList" style="margin-top:10px;"></div>
  </div>

  <div class="grid grid-2">
    <div class="card">
      <h2>2) Jauna sesija (viens hokeja vakars)</h2>

      <div class="row">
        <div>
          <label>Datums (pÄ“c izvÄ“les)</label>
          <input id="sessionDate" placeholder="piem. 2026-01-16 vai Piektdiena" />
        </div>
        <button id="createSession" class="btn-primary">Izveidot sesiju</button>
      </div>

      <div class="muted" style="margin-top:8px;">
        PÄ“c izveides atzÄ«mÄ“, kuri atnÄca. Tas katram pieskaita <b>+1 sesiju</b>.
        PÄ“c tam vari (vai nevari) pievienot raundus.
      </div>

      <div id="sessionsList" style="margin-top:12px;"></div>
    </div>

    <div class="card">
      <h2>3) AktÄ«vÄ sesija</h2>
      <div id="activeSessionBox" class="muted">Nav aktÄ«vas sesijas. Izveido jaunu vai izvÄ“lies no saraksta.</div>
    </div>
  </div>

  <div class="card">
    <h2>4) Reitings un statistika</h2>
    <div class="row">
      <button id="exportBtn">EksportÄ“t JSON</button>
      <label class="pill">
        ImportÄ“t JSON <input id="importFile" type="file" accept="application/json" style="display:none;">
      </label>
      <span class="muted">Tabula: Sesijas=ieraÅ¡anÄs, SpÄ“les=raundi, Uzvaras=no raundiem, ELO=dinamisks reitings.</span>
    </div>

    <div style="overflow:auto; max-height: 460px; margin-top:10px;">
      <table id="table">
        <thead>
          <tr>
            <th>#</th>
            <th>SpÄ“lÄ“tÄjs</th>
            <th>Sesijas</th>
            <th>SpÄ“les</th>
            <th>Uzvaras</th>
            <th>Win%</th>
            <th>ELO</th>
            <th>G</th>
            <th>A</th>
            <th>P</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:8px;">
      ELO: K=24, sÄkums 1000. 3-komandu raundÄ uzvarÄ“tÄji â€œuzvarâ€ pret abÄm citÄm komandÄm.
    </div>
  </div>
<script type="module">
  // Firebase SDK (web, bez npm)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import { 
    getFirestore, doc, getDoc, setDoc, updateDoc,
    collection, onSnapshot, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ğŸ” TAVS firebaseConfig
  const firebaseConfig = {
    apiKey: "AIzaSyCybzKkKkLuwerfvEjO0_a1uh8-NJuUqDI",
    authDomain: "sals-liga.firebaseapp.com",
    projectId: "sals-liga",
    storageBucket: "sals-liga.firebasestorage.app",
    messagingSenderId: "121070579037",
    appId: "1:121070579037:web:d5cfa4bb6841e5f25c8cb4"
  };

  // Init
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Anonymous login (bez e-pasta/paroles)
  signInAnonymously(auth).catch(console.error);

  // ğŸŒ League ID (VIENS KOPÄªGS VISIEM)
  window.LEAGUE_ID = "sals-liga";

  // ğŸ§  PalÄ«gobjekti globÄlai pieejai
  window.firebaseCtx = {
    db,
    auth,
    doc,
    getDoc,
    setDoc,
    updateDoc,
    collection,
    onSnapshot,
    serverTimestamp
  };
</script>

<script>
  const KEY = "dika_hokeja_liga_v2_sessions";

  const state = load() || {
    players: [],   // {id, name, sessions, games, wins, elo, g, a}
    sessions: [],  // {id, ts, label, attendees:[playerId], rounds:[round]}
    activeSessionId: null
  };
// ===== ONLINE (Firebase) slÄnis =====
let fb = null;
const LEAGUE_ID = window.LEAGUE_ID || "sals-liga";

let onlineEnabled = !!window.firebaseCtx;     // ja firebaseCtx ir, online var ieslÄ“gt
let onlineReady = false;
let myUid = null;

let isAdmin = false;
let myPlayerId = "";
myPlayerId = localStorage.getItem("myPlayerId") || "";
const nameOf = (id) => state.players.find(p => p.id === id)?.name || "??";
// kuru spÄ“lÄ“tÄju es esmu izvÄ“lÄ“jies (self-mode)

// Firestore ceÄ¼i (viena kopÄ«ga lÄ«ga)
function leagueDoc() { return fb.doc(fb.db, "leagues", LEAGUE_ID); }
function stateDoc()  { return fb.doc(fb.db, "leagues", LEAGUE_ID, "meta", "state"); }
function adminDoc()  { return fb.doc(fb.db, "leagues", LEAGUE_ID, "meta", "admin"); }
function usersDoc(uid){ return fb.doc(fb.db, "leagues", LEAGUE_ID, "users", uid); }

// UI helper
function toast(msg){
  alert(msg);
}

// Ensure league exists + subscribe to shared state
async function initOnlineIfPossible(){
  if (!window.firebaseCtx) return;
  // Wait for auth
  try {
    const auth = fb.auth;
    // auth.currentUser might be null right away; poll briefly
    for (let i=0;i<40;i++){
      if (auth.currentUser) break;
      await new Promise(r=>setTimeout(r, 100));
    }
    if (!auth.currentUser) {
      console.warn("Firebase auth not ready");
      return;
    }
    myUid = auth.currentUser.uid;

    // Ensure base docs exist
    const lref = leagueDoc();
    const l = await fb.getDoc(lref);
    if (!l.exists()){
      await fb.setDoc(lref, { createdAt: fb.serverTimestamp(), name: "SALS LÄ«ga" });
    }

    const aref = adminDoc();
    const a = await fb.getDoc(aref);
    if (!a.exists()){
      // nav admina vÄ“l â€“ atstÄjam tukÅ¡u (iestatÄ«sim ar pogu)
      await fb.setDoc(aref, { adminUid: null, createdAt: fb.serverTimestamp() });
    }

    // user profile doc
    const uref = usersDoc(myUid);
    const u = await fb.getDoc(uref);
    if (!u.exists()){
      await fb.setDoc(uref, { createdAt: fb.serverTimestamp(), myPlayerId: null });
    }

    // Subscribe: admin status
    fb.onSnapshot(aref, (snap)=>{
      const d = snap.data() || {};
      isAdmin = (d.adminUid && d.adminUid === myUid);
      renderAll();
    });

    // Subscribe: my profile
    fb.onSnapshot(uref, (snap)=>{
      const d = snap.data() || {};
      myPlayerId = d.myPlayerId || "";
localStorage.setItem("myPlayerId", myPlayerId);
renderAll();
    });

    // Subscribe: shared state
fb.onSnapshot(stateDoc(), (snap)=>{
  if (!snap.exists()) return;
  const remote = snap.data() || {};
  if (!remote.payload) return;

  let obj = null;
  try { obj = JSON.parse(remote.payload); } catch { obj = null; }
  if (!obj) return;

  state.players = obj.players || [];
  state.sessions = obj.sessions || [];
  state.activeSessionId = obj.activeSessionId || null;

  save();
  onlineReady = true;
  renderAll();
});

    // If no state doc exists yet, seed from local or empty
    const s = await fb.getDoc(stateDoc());
    if (!s.exists()){
      await pushStateToCloud(); // push local initial state
    }

  } catch (e){
    console.error(e);
    onlineEnabled = false;
  }
}

// Push entire state to cloud (admin only)
async function pushStateToCloud(){
  if (!onlineEnabled || !fb) return;
  if (!isAdmin) return;

await fb.setDoc(stateDoc(), {
  payload: JSON.stringify({
    players: state.players,
    sessions: state.sessions,
    activeSessionId: state.activeSessionId
  }),
  updatedAt: fb.serverTimestamp()
}, { merge: true });
}

// Lightweight â€œselfâ€ updates: attendance and GA events
async function selfSetMyPlayer(playerId){
  if (!onlineEnabled || !fb || !myUid) return;
  await fb.updateDoc(usersDoc(myUid), { myPlayerId: playerId });
}

async function selfToggleAttendance(sessionId, present){
  if (!onlineEnabled || !fb || !myPlayerId) return;
  // We store self-actions as "selfEvents" under the session for audit and recompute
  const sid = sessionId;
  const s = state.sessions.find(x=>x.id===sid);
  if (!s) return;

  // apply locally (optimistic)
  const had = (s.attendees||[]).includes(myPlayerId);
  if (present && !had){
    s.attendees.push(myPlayerId);
  }
  if (!present && had){
    // allow removing only if no rounds
    if ((s.rounds||[]).length>0) return toast("Nevar noÅ†emt ieraÅ¡anos, ja jau ir raundi. PalÅ«dz adminam.");
    s.attendees = s.attendees.filter(id=>id!==myPlayerId);
  }

  // recompute sessions count from scratch
  recomputeAllStatsFromSessions();

  // push full state? no (admin only). For self-mode, we push an event and let admin or everyone recompute via state.
  // Simplest: allow self to write the whole state doc too, BUT limit what they can change by convention.
  // Since rules are simple now, we enforce in UI: self only changes own attendance/GA, but the write is whole doc.
  // We'll do a "patch" write of sessions/players. (Safer than full doc overwrite? We'll merge.)
await fb.setDoc(stateDoc(), {
  payload: JSON.stringify({
    players: state.players,
    sessions: state.sessions,
    activeSessionId: state.activeSessionId
  }),
  updatedAt: fb.serverTimestamp()
}, { merge: true });

  save(); renderAll();
}

async function selfAddGA(lastRoundId, type){
  if (!onlineEnabled || !fb || !myPlayerId) return;
  const s = getActiveSession();
  if (!s) return toast("Nav aktÄ«vas sesijas.");
  const r = (s.rounds||[]).find(x=>x.id===lastRoundId);
  if (!r) return toast("Nav pÄ“dÄ“jÄ raunda.");

  r.gaEvents = r.gaEvents || [];
  r.gaEvents.push({ type, playerId: myPlayerId, byUid: myUid, ts: Date.now() });

  recomputeAllStatsFromSessions();

await fb.setDoc(stateDoc(), {
  payload: JSON.stringify({
    players: state.players,
    sessions: state.sessions,
    activeSessionId: state.activeSessionId
  }),
  updatedAt: fb.serverTimestamp()
}, { merge: true });

  save(); renderAll();
}

async function selfUndoLastGA(lastRoundId){
  if (!onlineEnabled || !fb || !myPlayerId) return;
  const s = getActiveSession();
  if (!s) return;
  const r = (s.rounds||[]).find(x=>x.id===lastRoundId);
  if (!r || !(r.gaEvents||[]).length) return;

  // remove last GA event created by me for my player
  for (let i=r.gaEvents.length-1;i>=0;i--){
    const ev = r.gaEvents[i];
    if (ev.playerId === myPlayerId){
      r.gaEvents.splice(i,1);
      break;
    }
  }

  recomputeAllStatsFromSessions();

await fb.setDoc(stateDoc(), {
  payload: JSON.stringify({
    players: state.players,
    sessions: state.sessions,
    activeSessionId: state.activeSessionId
  }),
  updatedAt: fb.serverTimestamp()
}, { merge: true });

  save(); renderAll();
}

  function uid() { return Math.random().toString(36).slice(2,10); }
  function save() { localStorage.setItem(KEY, JSON.stringify(state)); }
  function load() { try { return JSON.parse(localStorage.getItem(KEY)); } catch { return null; } }
  const el = (id) => document.getElementById(id);
  function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function fmtTs(ts){ return new Date(ts).toLocaleString(); }

  // --- Players ---
  function addPlayer(name) {
    name = (name||"").trim();
    if (!name) return;
    if (state.players.some(p => p.name.toLowerCase() === name.toLowerCase())) return alert("Å Äds spÄ“lÄ“tÄjs jau ir.");
    state.players.push({ id: uid(), name, sessions: 0, games: 0, wins: 0, elo: 1000, g: 0, a: 0 });
    save(); renderAll();
    pushStateToCloud();
  }

  function playerUsed(id){
    return state.sessions.some(s => (s.attendees||[]).includes(id) || (s.rounds||[]).some(r => (r.participants||[]).includes(id)));
  }

  function deletePlayer(id) {
    if (playerUsed(id)) return alert("Nevar dzÄ“st: spÄ“lÄ“tÄjs jau ir sesijÄs/raundos. (Varam pievienot 'arhivÄ“t'.)");
    state.players = state.players.filter(p => p.id !== id);
    save(); renderAll();
    pushStateToCloud();
  }

  function renderPlayers() {
    const list = state.players
      .slice()
      .sort((a,b)=> a.name.localeCompare(b.name, 'lv'))
      .map(p => `<span class="pill">${escapeHtml(p.name)} <button class="btn-sm btn-ghost" data-del="${p.id}" title="DzÄ“st">Ã—</button></span>`)
      .join(" ");
    el("playerList").innerHTML = list || `<span class="muted">Nav spÄ“lÄ“tÄju. Pievieno pirmos!</span>`;
  }

  // --- Sessions ---
  function createSession(label) {
    const s = {
      id: uid(),
      ts: Date.now(),
      label: (label||"").trim() || "Hokeja sesija",
      attendees: [],
      rounds: [],
      sessionGA: {},   // { [playerId]: {g:0, a:0} } kopÄ“jais G/A sesijai
      autoTeams: null,     // fiksÄ“tas komandas Å¡ai sesijai
      teamWLD: null,       // [{w,l,d}, ...] tikpat cik komandu
    };
    state.sessions.push(s);
    state.activeSessionId = s.id;
    save(); renderAll();
    pushStateToCloud();
  }

  function setActiveSession(id){
    state.activeSessionId = id;
    save(); renderAll();
  }

  function getActiveSession(){
    return state.sessions.find(s => s.id === state.activeSessionId) || null;
  }
  function ensureSessionGA(s, pid){
  s.sessionGA = s.sessionGA || {};
  s.sessionGA[pid] = s.sessionGA[pid] || { g: 0, a: 0 };
  return s.sessionGA[pid];
}

function renderSessionGASummary(){
  const s = getActiveSession();
  if (!s) return;
  const box = document.getElementById("gaSummary");
  if (!box) return;

  const entries = Object.entries(s.sessionGA || {});
  if (!entries.length){
    box.textContent = "Sesijas G/A: â€”";
    return;
  }

  // sakÄrto pÄ“c G tad A
  entries.sort(([,a],[,b]) => (b.g - a.g) || (b.a - a.a));

  const line = entries
    .map(([pid,ga]) => `${nameOf(pid)} ${ga.g}-${ga.a}`)
    .join(" Â· ");

  box.textContent = `Sesijas G/A: ${line}`;
}

  function toggleAttendance(playerId, present){
    const s = getActiveSession();
    if (!s) return;

    const had = s.attendees.includes(playerId);
    if (present && !had){
      s.attendees.push(playerId);
      // sessions +1
      const p = state.players.find(x => x.id === playerId);
      if (p) p.sessions += 1;
    }
    if (!present && had){
      // Removing attendance is tricky if rounds already exist; disallow to keep integrity.
      if ((s.rounds||[]).length > 0){
        return alert("Nevar noÅ†emt ieraÅ¡anos, ja jau ir raundi. (DzÄ“s raundus vai izveido jaunu sesiju.)");
      }
      s.attendees = s.attendees.filter(id => id !== playerId);
      const p = state.players.find(x => x.id === playerId);
      if (p && p.sessions > 0) p.sessions -= 1;
    }
    save(); renderAll();
    pushStateToCloud();
  }

  function deleteSession(sessionId){
    const s = state.sessions.find(x => x.id === sessionId);
    if (!s) return;

    // Roll back stats from this session (attendance + rounds)
    // 1) attendance
    for (const pid of (s.attendees||[])){
      const p = state.players.find(x => x.id === pid);
      if (p && p.sessions > 0) p.sessions -= 1;
    }
    // 2) rounds effects: games, wins, elo, g, a
    // To keep it simple and reliable, we will NOT attempt to reverse ELO precisely round-by-round.
    // Instead: recompute everything from scratch after removing.
    state.sessions = state.sessions.filter(x => x.id !== sessionId);
    if (state.activeSessionId === sessionId) state.activeSessionId = state.sessions.at(-1)?.id || null;

    recomputeAllStatsFromSessions();
    save(); renderAll();
    pushStateToCloud();
  }

  // --- Rounds / Teaming ---
  function suggestedSplit(n){
    // Returns array of team sizes (2 or 3 teams) for common cases, else a reasonable split.
    if (n === 6) return [3,3];
    if (n === 7) return [4,3];
    if (n === 8) return [4,4];
    if (n === 9) return [3,3,3];
    if (n === 10) return [4,3,3];
    if (n === 11) return [4,4,3];
    if (n === 12) return [4,4,4];
    // fallback: prefer 3 teams if >=9, else 2 teams
    if (n >= 9){
      // split into 3 teams as evenly as possible
      const base = Math.floor(n/3);
      const rem = n % 3;
      const sizes = [base, base, base];
      for (let i=0;i<rem;i++) sizes[i] += 1;
      return sizes;
    } else {
      const a = Math.ceil(n/2);
      const b = n - a;
      return [a,b];
    }
  }

  function shuffle(arr){
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function makeTeams(attendees){
    const n = attendees.length;
    const sizes = suggestedSplit(n);
    const ids = shuffle(attendees);

    const teams = [];
    let idx = 0;
    for (let t=0;t<sizes.length;t++){
      teams.push(ids.slice(idx, idx + sizes[t]));
      idx += sizes[t];
    }
    return teams; // array of arrays
  }

  function eloExpected(rA, rB){
    return 1 / (1 + Math.pow(10, (rB - rA)/400));
  }

  function eloUpdateTeamVsTeam(teamAIds, teamBIds, scoreA, scoreB, K=24){
    // Use average team rating, then apply delta to each member scaled by 1 (simple)
    const avg = (ids) => ids.reduce((s,id)=> s + (state.players.find(p=>p.id===id)?.elo ?? 1000), 0) / Math.max(1,ids.length);
    const rA = avg(teamAIds), rB = avg(teamBIds);
    const eA = eloExpected(rA, rB);
    const eB = 1 - eA;

    const sA = scoreA, sB = scoreB;
    const dA = K * (sA - eA);
    const dB = K * (sB - eB);

    for (const id of teamAIds){
      const p = state.players.find(x => x.id === id);
      if (p) p.elo += dA;
    }
    for (const id of teamBIds){
      const p = state.players.find(x => x.id === id);
      if (p) p.elo += dB;
    }
  }

  function addRound({teams, winnerIndex, scoreText, notes, gaEvents}){
    const s = getActiveSession();
    if (!s) return alert("Nav aktÄ«vas sesijas.");

    const participants = teams.flat();
    if (participants.length < 2) return alert("Par maz spÄ“lÄ“tÄju.");
    const uniq = new Set(participants);
    if (uniq.size !== participants.length) return alert("VienÄ raundÄ spÄ“lÄ“tÄjs nedrÄ«kst bÅ«t 2 komandÄs.");

    // Create round object
    const round = {
      id: uid(),
      ts: Date.now(),
      teams, // array of arrays
      winnerIndex, // 0..teams-1
      scoreText: (scoreText||"").trim(),
      notes: (notes||"").trim(),
      gaEvents: gaEvents || [] // {type:'G'|'A', playerId}
    };
    s.rounds.push(round);

    // Update stats: games+1 for participants
    for (const pid of participants){
      const p = state.players.find(x => x.id === pid);
      if (p) p.games += 1;
    }
    // wins+1 for winners
    const winners = teams[winnerIndex] || [];
    for (const pid of winners){
      const p = state.players.find(x => x.id === pid);
      if (p) p.wins += 1;
    }

    // Goals/assists
    for (const ev of (round.gaEvents||[])){
      const p = state.players.find(x => x.id === ev.playerId);
      if (!p) continue;
      if (ev.type === "G") p.g += 1;
      if (ev.type === "A") p.a += 1;
    }

    // ELO
    // If 2 teams: one matchup.
    // If 3 teams: winner beats both others (two matchups).
    // If >3 teams: treat winner vs each other (rare; still works).
    const K = 24;
    const W = teams[winnerIndex] || [];
    for (let i=0;i<teams.length;i++){
      if (i === winnerIndex) continue;
      const L = teams[i];
      // winner gets 1, loser gets 0
      eloUpdateTeamVsTeam(W, L, 1, 0, K);
    }

    save(); renderAll();
    pushStateToCloud();
  }

  function deleteRound(roundId){
    // Similar to session deletion: recompute to keep ELO correct.
    const s = getActiveSession();
    if (!s) return;
    s.rounds = (s.rounds||[]).filter(r => r.id !== roundId);
    recomputeAllStatsFromSessions();
    save(); renderAll();
    pushStateToCloud();
  }

  function recomputeAllStatsFromSessions(){
    // Reset players
    for (const p of state.players){
      p.sessions = 0; p.games = 0; p.wins = 0; p.elo = 1000; p.g = 0; p.a = 0;
    }
    // Re-apply sessions and rounds in chronological order
    const sessions = state.sessions.slice().sort((a,b)=>a.ts-b.ts);
    for (const s of sessions){
      for (const pid of (s.attendees||[])){
        const p = state.players.find(x => x.id === pid);
        if (p) p.sessions += 1;
      }
      const rounds = (s.rounds||[]).slice().sort((a,b)=>a.ts-b.ts);
      for (const r of rounds){
        const participants = (r.teams||[]).flat();
        for (const pid of participants){
          const p = state.players.find(x => x.id === pid);
          if (p) p.games += 1;
        }
        const winners = (r.teams||[])[r.winnerIndex] || [];
        for (const pid of winners){
          const p = state.players.find(x => x.id === pid);
          if (p) p.wins += 1;
        }
        for (const ev of (r.gaEvents||[])){
          const p = state.players.find(x => x.id === ev.playerId);
          if (!p) continue;
          if (ev.type === "G") p.g += 1;
          if (ev.type === "A") p.a += 1;
        }
        const teams = r.teams || [];
        const W = teams[r.winnerIndex] || [];
        for (let i=0;i<teams.length;i++){
          if (i === r.winnerIndex) continue;
          eloUpdateTeamVsTeam(W, teams[i], 1, 0, 24);
        }
      }
      // Sesijas kopÄ“jais G/A
const sga = s.sessionGA || {};
for (const [pid, ga] of Object.entries(sga)){
  const p = state.players.find(x => x.id === pid);
  if (!p) continue;
  p.g += Number(ga.g || 0);
  p.a += Number(ga.a || 0);
}
      // Session-level GA (krÄjam pa sesiju, nevis pa raundu)
if (s.sessionGA){
  for (const [pid, ga] of Object.entries(s.sessionGA)){
    const p = state.players.find(x => x.id === pid);
    if (!p) continue;
    p.g += Number(ga.g || 0);
    p.a += Number(ga.a || 0);
  }
}
    }
  }

  // --- Rendering Active Session UI ---
  function renderSessionsList(){
    const sorted = state.sessions.slice().sort((a,b)=>b.ts-a.ts);
    el("sessionsList").innerHTML = sorted.map(s => {
      const isActive = s.id === state.activeSessionId;
      const att = (s.attendees||[]).length;
      const rnd = (s.rounds||[]).length;
      return `<div class="card" style="margin:8px 0;">
        <div class="row" style="justify-content:space-between;">
          <div>
            <b>${escapeHtml(s.label)}</b> <span class="muted">(${fmtTs(s.ts)})</span><br/>
            ${onlineEnabled ? `
  <div style="margin-top:8px;">
    ${isAdmin ? `<span class="pill ok">Admin</span>` : `<button id="becomeAdmin" class="btn-sm btn-primary">IestatÄ«t mani kÄ adminu</button>`}
  <span class="pill">Mans profils: ${myPlayerId ? escapeHtml(nameOf(myPlayerId)) : "nav izvÄ“lÄ“ts"}</span>
    <button data-pickme="1" class="btn-sm btn-ghost">IzvÄ“lÄ“ties savu vÄrdu</button>
  </div>
` : ``}

            <span class="pill">AtnÄkuÅ¡i: ${att}</span>
            <span class="pill">Raundi: ${rnd}</span>
            ${isActive ? `<span class="pill ok">AktÄ«va</span>` : ``}
          </div>
          <div class="row">
            <button class="btn-sm btn-ghost" data-setactive="${s.id}">AtvÄ“rt</button>
            <button class="btn-sm danger" data-delsession="${s.id}">DzÄ“st sesiju</button>
          </div>
        </div>
      </div>`;
    }).join("") || `<span class="muted">Nav sesiju. Izveido pirmo.</span>`;
  }

function renderActiveSession(){
  const s = getActiveSession();
 // W-L-D ievades lauki katrai komandai (Quick round)
  const wldInputsHtml = Array.from({ length: teamCount }).map((_, i) => {
    const label = String.fromCharCode(65 + i); // A,B,C
    return `
      <div>
        <label>${label} W-L-D</label>
        <input id="q_wld_${i}" placeholder="piem. 5-4-2" />
      </div>
    `;
  }).join("");  
  if (!s){
    el("activeSessionBox").innerHTML = `<span class="muted">Nav aktÄ«vas sesijas. Izveido jaunu vai izvÄ“lies no saraksta.</span>`;
    return;
  }

  // cache: ja sesijai jau ir fiksÄ“tas auto komandas, ieliec UI cache
  quickTeamsCache = s.autoTeams || null;

  const attendees = (s.attendees||[]).slice();
  const n = attendees.length;
  const split = suggestedSplit(n);
  const teamCount = split.length;

  const splitText = split.length === 2
    ? `${split[0]}v${split[1]}`
    : `${split[0]}v${split[1]}v${split[2]}`;
    // Winner options (A/B/C + NeizÅ¡Ä·irts)
  const winnerOptions =
    `<option value="-1">NeizÅ¡Ä·irts</option>` +
    Array.from({ length: teamCount }).map((_, i) => {
      const label = String.fromCharCode(65 + i); // A,B,C
      return `<option value="${i}">${label}</option>`;
    }).join("");

  // Attendance checklist
  const checkList = state.players
    .slice()
    .sort((a,b)=>a.name.localeCompare(b.name,'lv'))
    .map(p => {
      const checked = s.attendees.includes(p.id);
      return `<label class="pill" style="cursor:pointer;">
        <input type="checkbox" data-att="${p.id}" ${checked ? "checked" : ""} /> ${escapeHtml(p.name)}
      </label>`;
    }).join(" ");

  // Rounds list
  const rounds = (s.rounds||[]).slice().sort((a,b)=>b.ts-a.ts);
  const roundsHtml = rounds.map(r => {
    const teams = r.teams || [];
    const teamLabels = teams.map((t,idx)=>{
      const label = String.fromCharCode(65+idx); // A, B, C...
      const players = t.map(nameOf).join(", ");
      const win = (idx === r.winnerIndex) ? " ğŸ†" : "";
      return `<div class="muted"><b>${label}${win}</b>: ${escapeHtml(players)}</div>`;
    }).join("");
    const ga = (r.gaEvents||[]).map(ev => `${ev.type}:${nameOf(ev.playerId)}`).join(", ");
    return `<div class="card" style="margin:8px 0;">
      <div class="row" style="justify-content:space-between;">
        <div>
          <b>${fmtTs(r.ts)}</b>
          ${r.scoreText ? ` Â· <span class="pill">${escapeHtml(r.scoreText)}</span>` : ""}
        </div>
        ${isAdmin ? `<button class="btn-sm danger" data-delround="${r.id}">DzÄ“st raundu</button>` : ``}
      </div>
      ${teamLabels}
      ${r.notes ? `<div style="margin-top:6px;">ğŸ“ ${escapeHtml(r.notes)}</div>` : ``}
      ${ga ? `<div class="muted" style="margin-top:6px;">G/A: ${escapeHtml(ga)}</div>` : ``}
    </div>`;
  }).join("") || `<span class="muted">Nav raundu. (Tas ir ok.)</span>`;

  // Round creator UI
  const attendeeOptions = attendees.map(id => `<option value="${id}">${escapeHtml(nameOf(id))}</option>`).join("");
  const makeSelect = (id) => `<select id="${id}"><option value="">â€”</option>${attendeeOptions}</select>`;

  let manualTeamsHtml = "";
  for (let t=0;t<teamCount;t++){
    const size = split[t];
    const label = String.fromCharCode(65+t);
    manualTeamsHtml += `<div class="card" style="margin:0;">
      <div><b>${label} komanda</b> <span class="muted">(${size})</span></div>
      <div class="row" style="margin-top:6px;">${Array.from({length:size}).map((_,i)=>makeSelect(`m_${t}_${i}`)).join("")}</div>
    </div>`;
  }
    
  const winnerOptions =
  `<option value="-1">NeizÅ¡Ä·irts</option>` +
  Array.from({ length: teamCount }).map((_, i) => {
    const label = String.fromCharCode(65 + i);
    return `<option value="${i}">${label}</option>`;
  }).join("");

  el("activeSessionBox").innerHTML = `
    <div>
      <div class="row" style="justify-content:space-between;">
        <div>
          <b>${escapeHtml(s.label)}</b> <span class="muted">(${fmtTs(s.ts)})</span><br/>
          <span class="pill">AtnÄkuÅ¡i: ${n}</span>
          <span class="pill">Ieteiktais formÄts: ${splitText}</span>

          ${onlineEnabled ? `
            <div style="margin-top:8px;">
              ${isAdmin
                ? `<span class="pill ok">Admin</span>`
                : `<button id="becomeAdminList" class="btn-sm btn-primary">IestatÄ«t mani kÄ adminu</button>`
              }
              <span class="pill">Mans profils: ${myPlayerId ? escapeHtml(nameOf(myPlayerId)) : "nav izvÄ“lÄ“ts"}</span>
              <button data-pickme="1" class="btn-sm btn-ghost">IzvÄ“lÄ“ties savu vÄrdu</button>
            </div>
          ` : ``}
        </div>
        <div class="row">
          <button id="autoTeams" class="btn-sm btn-primary">Auto komandas</button>
          ${isAdmin ? `<button class="btn-sm danger" data-delsession="${s.id}">DzÄ“st sesiju</button>` : ``}
        </div>
      </div>

      <div class="card" style="margin:10px 0;">
        <div><b>AtnÄkuÅ¡ie</b> <span class="muted">(atzÄ«mÄ“, kuri ir klÄt â€” tas skaita sesijas)</span></div>
        <div style="margin-top:8px;">${checkList}</div>
        <div class="muted" style="margin-top:8px;">âš ï¸ Ja jau ir raundi, ieraÅ¡anos noÅ†emt nevar (lai nesajÅ«k statistika).</div>
      </div>

      <div class="card warn" style="margin:10px 0;">
        <div><b>Quick round</b> <span class="muted">(Ätri: auto komandas â†’ izvÄ“lies uzvarÄ“tÄju â†’ saglabÄ)</span></div>

        <div id="quickTeamsBox" class="muted" style="margin-top:8px;">
          Spied <b>Auto komandas</b>, lai Ä£enerÄ“tu raundu.
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>Komandu bilance (W-L-D)</label>
<div id="q_wld" class="row" style="gap:10px; flex-wrap:wrap;">
  ${wldInputsHtml}
</div>
          </div>
          <div>

          </div>
          <div style="flex:1; min-width:260px;">
            <label>PiezÄ«mes (pÄ“c izvÄ“les)</label>
            <input id="q_notes" placeholder="piem. komandas mainÄ«jÄm pÄ“c 5 min" style="width:100%;" />
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div><b>Goals / Assists</b> <span class="muted">(klikÅ¡Ä·ini pÄ“c vajadzÄ«bas; viss ir optional)</span></div>
          <div id="gaBox" class="muted" style="margin-top:8px;">Nav auto komandÄs spÄ“lÄ“tÄju.</div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="saveQuickRound" class="btn-primary">SaglabÄt raundu</button>
          <button id="clearGA" class="btn-sm btn-ghost">NotÄ«rÄ«t G/A Å¡im raundam</button>
        </div>

        ${(!isAdmin && onlineEnabled) ? `
          <div class="muted" style="margin-top:10px;">
            SpÄ“lÄ“tÄjs reÅ¾Ä«ms: izvÄ“lies savu vÄrdu un tad vari sev pievienot G/A (nÄkamajÄ solÄ« pieliksim â€œ+G/+A/Undoâ€ pogas tieÅ¡i tev).
          </div>
        ` : ``}
      </div>

      <div class="card" style="margin:10px 0;">
        <div><b>ManuÄls raunds</b> <span class="muted">(ja gribi pats salikt komandas)</span></div>
        <div class="grid grid-${teamCount}" style="margin-top:8px;">${manualTeamsHtml}</div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label>UzvarÄ“tÄjs</label>
            <select id="m_winner">${winnerOptions}</select>
          </div>

        ${wldInputs}

          <div>
            <label>RezultÄts (pÄ“c izvÄ“les)</label>
            <input id="m_score" placeholder="piem. 2-1-0 vai 3-2" />
          </div>
          <div style="flex:1; min-width:260px;">
            <label>PiezÄ«mes (pÄ“c izvÄ“les)</label>
            <input id="m_notes" placeholder="piem. 4v4v3" style="width:100%;" />
          </div>
          <button id="saveManualRound" class="btn-primary">SaglabÄt manuÄlu raundu</button>
        </div>

        <div class="muted" style="margin-top:6px;">
          Padoms: manuÄlajÄ raundÄ izvÄ“lies unikÄlus spÄ“lÄ“tÄjus (bez dublikÄtiem).
        </div>
      </div>

      <div class="card">
        <div><b>Raundi Å¡ajÄ sesijÄ</b></div>
        <div style="margin-top:8px;">${roundsHtml}</div>
      </div>
    </div>
  `;

  // Wire active session handlers
  wireActiveSessionHandlers();
    // pÄ“c rendera, ja sesijai ir autoTeams, parÄdÄm tÄs
if (s.autoTeams) buildQuickTeamsUI(s.autoTeams);
    if (quickTeamsCache) buildQuickTeamsUI(quickTeamsCache);
}

  // --- Quick round state (UI-only) ---
  let quickTeamsCache = null; // array of arrays
// quickGA vairs nelietojam â€” G/A krÄjam sesijÄ

  function buildQuickTeamsUI(teams){
    const html = teams.map((t,idx)=>{
      const label = String.fromCharCode(65+idx);
     return `<div class="card" style="margin:6px 0;">
  <b>${label} komanda</b>
  ${(() => {
    const s = getActiveSession();
    const wld = s?.teamWLD?.[idx];
    return wld ? ` <span class="pill">W-L-D: ${wld.w}-${wld.l}-${wld.d}</span>` : "";
  })()}
  <span class="muted">(${t.length})</span><br/>
  ${t.map(id=>`<span class="pill">${escapeHtml(nameOf(id))}</span>`).join("")}
</div>`;
    }).join("");
    el("quickTeamsBox").innerHTML = html || `<span class="muted">Nav komandu.</span>`;

    // GA buttons
    const players = teams.flat();
    if (players.length === 0){
      el("gaBox").innerHTML = `<span class="muted">Nav auto komandÄs spÄ“lÄ“tÄju.</span>`;
      return;
    }
    el("gaBox").innerHTML = players.map(pid=>{
      const nm = escapeHtml(nameOf(pid));
      return `<span class="pill">
        ${nm}
        <button class="btn-sm btn-ghost" data-ga="G" data-p="${pid}">+G</button>
        <button class="btn-sm btn-ghost" data-ga="A" data-p="${pid}">+A</button>
      </span>`;
    }).join(" ");
    // Sesijas G/A rindiÅ†a virs pogÄm
let sum = document.getElementById("gaSummary");
if (!sum){
  sum = document.createElement("div");
  sum.id = "gaSummary";
  sum.className = "muted";
  sum.style.marginBottom = "8px";
  el("gaBox").parentElement.insertBefore(sum, el("gaBox"));
}
renderSessionGASummary();
  }

  function wireActiveSessionHandlers(){
// Attendance toggles (FIX: allow clicking even with global click handler)
document.querySelectorAll('input[type="checkbox"][data-att]').forEach(cb => {
  cb.addEventListener("click", (e) => e.stopPropagation());

  cb.onclick = (ev) => {
    ev.stopPropagation(); // lai body click handler netraucÄ“

    const pid = cb.getAttribute("data-att");
    const present = cb.checked;

    // online: ja neesi admins, tad self reÅ¾Ä«ms; ja esi admins, tad parastais
if (onlineEnabled && !isAdmin) {
  selfToggleAttendance(state.activeSessionId, present);
} else {
  toggleAttendance(pid, present);
}
  };
});

  // Auto teams
  const autoBtn = document.getElementById("autoTeams");
  if (autoBtn){
    autoBtn.onclick = () => {
  const s = getActiveSession();
  if (!s) return;
  if ((s.attendees||[]).length < 2) return alert("AtzÄ«mÄ“ vismaz 2 atnÄkuÅ¡os.");

  // 1) uzÄ£enerÄ“ un FIKSÄ’ komandÄm Å¡ai sesijai
  s.autoTeams = makeTeams(s.attendees);

  // 2) uztaisa W-L-D tik komandÄm, cik ir (A/B/C...)
  s.teamWLD = s.autoTeams.map(() => ({ w: 0, l: 0, d: 0 }));

  // 3) UI cache
  quickTeamsCache = s.autoTeams;
  quickGA = [];

  save();
  pushStateToCloud();     // ja tu esi admin, tas aizies uz firebase; ja ne, nekaitÄ“s
  renderAll();            // lai noteikti uzreiz parÄdÄs
};
  }

  // Save quick round
  const saveQ = document.getElementById("saveQuickRound");
  if (saveQ){
    saveQ.onclick = () => {
      const s = getActiveSession();
      if (!s) return;
      if (!quickTeamsCache) return alert("Vispirms spied 'Auto komandas'.");
      const wi = Number(document.getElementById("q_winner").value);
      // --- W/L/D update (sesijas komandÄm) ---
if (!s.autoTeams || !s.teamWLD) {
  return alert("Vispirms uzspied 'Auto komandas', lai fiksÄ“tu komandas Å¡ai sesijai.");
}

// ja kÄds ir izdomÄjis quickTeamsCache citÄdÄk, piespieÅ¾am izmantot sesijas komandas
quickTeamsCache = s.autoTeams;

if (wi === -1) {
  // neizÅ¡Ä·irts visÄm komandÄm
  s.teamWLD.forEach(t => t.d++);
} else {
  // uzvara vienai komandai, pÄrÄ“jÄm zaudÄ“jums
  s.teamWLD[wi].w++;
  s.teamWLD.forEach((t, idx) => { if (idx !== wi) t.l++; });
}
      const score = document.getElementById("q_score").value;
      const notes = document.getElementById("q_notes").value;
      // --- W-L-D inputs pa komandÄm (A/B/C) ---
const wld = [];
for (let i=0;i<teamCount;i++){
  const raw = (document.getElementById(`q_wld_${i}`)?.value || "").trim();
  if (!raw) { wld.push({w:0,l:0,d:0}); continue; } // atÄ¼aujam tukÅ¡u = 0-0-0

  const m = raw.match(/^(\d+)\s*-\s*(\d+)\s*-\s*(\d+)$/);
  if (!m) return alert(`Nepareizs W-L-D formÄts komandai ${String.fromCharCode(65+i)}. PiemÄ“rs: 5-4-2`);
  wld.push({ w:+m[1], l:+m[2], d:+m[3] });
}

// garantÄ“jam storage sesijai
s.teamWLD = s.teamWLD || Array.from({length: teamCount}).map(()=>({w:0,l:0,d:0}));

// pieskaitÄm sesijas kopÄ“jam W-L-D
for (let i=0;i<teamCount;i++){
  s.teamWLD[i].w += wld[i].w;
  s.teamWLD[i].l += wld[i].l;
  s.teamWLD[i].d += wld[i].d;
}
      addRound({ teams: quickTeamsCache, winnerIndex: wi, scoreText: score, notes });
      document.getElementById("q_score").value = "";
      document.getElementById("q_notes").value = "";
      quickGA = [];
      renderAll();
    };
  }

  const clearGA = document.getElementById("clearGA");
  if (clearGA){
    clearGA.onclick = () => {
      quickGA = [];
      renderAll();
    };
  }

  // Save manual round
  const saveM = document.getElementById("saveManualRound");
  if (saveM){
    saveM.onclick = () => {
      const s = getActiveSession();
      if (!s) return;

      const n = (s.attendees||[]).length;
      if (n < 2) return alert("AtzÄ«mÄ“ atnÄkuÅ¡os.");

      const split = suggestedSplit(n);
      const teamCount = split.length;

      const teams = [];
      for (let t=0;t<teamCount;t++){
        const size = split[t];
        const ids = [];
        for (let i=0;i<size;i++){
          const v = document.getElementById(`m_${t}_${i}`).value;
          if (v) ids.push(v);
        }
        if (ids.length !== size) return alert("ManuÄlajÄ raundÄ visÄm komandÄm jÄbÅ«t pilnÄ sastÄvÄ.");
        teams.push(ids);
      }

      const participants = teams.flat();
      const uniq = new Set(participants);
      if (uniq.size !== participants.length) return alert("Vienu un to paÅ¡u spÄ“lÄ“tÄju nevar ielikt 2 reizes.");

      const wi = Number(document.getElementById("m_winner").value);
      const score = document.getElementById("m_score").value;
      const notes = document.getElementById("m_notes").value;

      addRound({ teams: quickTeamsCache, winnerIndex: wi, scoreText: score, notes });
      document.getElementById("m_score").value = "";
      document.getElementById("m_notes").value = "";
      renderAll();
    };
  }

  // Delete round buttons
  document.querySelectorAll("[data-delround]").forEach(btn=>{
    btn.onclick = () => {
      if (!confirm("DzÄ“st Å¡o raundu?")) return;
      deleteRound(btn.getAttribute("data-delround"));
    };
  });
}
// Pick my player (works for BOTH buttons)
  
  // Become admin
  const become = document.getElementById("becomeAdmin");
  if (become) {
    become.onclick = async () => {
      if (!onlineEnabled || !fb) return alert("Online nav pieejams.");
      try {
        const ref = adminDoc();
        const snap = await fb.getDoc(ref);
        const d = snap.data() || {};
        if (d.adminUid && d.adminUid !== myUid) return alert("Admins jau ir iestatÄ«ts.");
        await fb.setDoc(ref, { adminUid: myUid, createdAt: fb.serverTimestamp() }, { merge: true });
        alert("Tu tagad esi admins âœ…");
        renderAll();
      } catch (e) {
        alert("Admin kÄ¼Å«da: " + e.message);
      }
    };
  }
    // GA buttons
     // we'll re-bind below properly in global handler

    // Save quick round
    const saveQ = document.getElementById("saveQuickRound");
    if (saveQ){
      saveQ.onclick = () => {
        const s = getActiveSession();
        if (!s) return;
        if (!quickTeamsCache) return alert("Vispirms spied 'Auto komandas'.");
       // nolasa W-L-D katrai komandai
const teamRes = Array.from({length: (quickTeamsCache?.length || 0)}).map((_, i) => {
  const w = Number(document.getElementById(`q_w_${i}`)?.value || 0);
  const l = Number(document.getElementById(`q_l_${i}`)?.value || 0);
  const d = Number(document.getElementById(`q_d_${i}`)?.value || 0);
  return { w, l, d };
});

// uzvarÄ“tÄju nosaka pÄ“c punktiem (W=2, D=1, L=0) â€” vari mainÄ«t, ja gribi
const points = teamRes.map(r => r.w*2 + r.d);
let wi = 0;
for (let i=1;i<points.length;i++){
  if (points[i] > points[wi]) wi = i;
}

// score lauku vari lietot brÄ«vajam tekstam (piem. â€œ5-4-2 / 4-4-3 / 3-6-2â€)
const score = document.getElementById("q_score").value;
const notes = document.getElementById("q_notes").value;

addRound({
  teams: quickTeamsCache,
  winnerIndex: wi,          // iekÅ¡Ä“ji vajag ELO/wins, bet tu UI vairs neizvÄ“lies â€œvienu uzvarÄ“tÄjuâ€
  scoreText: score,
  notes,
  gaEvents: quickGA,
  teamRes               // <- Å¡is ir JAUNS lauks
});

// pÄ“c saglabÄÅ¡anas notÄ«rÄm
document.getElementById("q_score").value = "";
document.getElementById("q_notes").value = "";
quickGA = [];
renderAll();
        document.getElementById("q_score").value = "";
        document.getElementById("q_notes").value = "";
        quickGA = [];
        renderAll();
      };
    }

    const clearGA = document.getElementById("clearGA");
    if (clearGA){
      clearGA.onclick = () => {
        quickGA = [];
        renderAll();
      };
    }

    // Save manual round
    const saveM = document.getElementById("saveManualRound");
    if (saveM){
      saveM.onclick = () => {
        const s = getActiveSession();
        if (!s) return;

        const n = (s.attendees||[]).length;
        if (n < 2) return alert("AtzÄ«mÄ“ atnÄkuÅ¡os.");

        const split = suggestedSplit(n);
        const teamCount = split.length;

        const teams = [];
        for (let t=0;t<teamCount;t++){
          const size = split[t];
          const ids = [];
          for (let i=0;i<size;i++){
            const v = document.getElementById(`m_${t}_${i}`).value;
            if (v) ids.push(v);
          }
          if (ids.length !== size) return alert("ManuÄlajÄ raundÄ visÄm komandÄm jÄbÅ«t pilnÄ sastÄvÄ.");
          teams.push(ids);
        }

        const participants = teams.flat();
        const uniq = new Set(participants);
        if (uniq.size !== participants.length) return alert("Vienu un to paÅ¡u spÄ“lÄ“tÄju nevar ielikt 2 reizes.");
        // optional: ensure all attendees are used? not required, but usually yes
        // We'll allow subset if someone sÄ“Å¾ malÄ.

        const wi = Number(document.getElementById("m_winner").value);
        const score = document.getElementById("m_score").value;
        const notes = document.getElementById("m_notes").value;

        addRound({teams, winnerIndex: wi, scoreText: score, notes, gaEvents: []});
        document.getElementById("m_score").value = "";
        document.getElementById("m_notes").value = "";
        renderAll();
      };
    }

    // Delete round buttons
document.body.addEventListener("click", (e) => {

;
// --- GA (+G/+A) quick round: krÄjam sesijÄ ---
const gaBtn = e.target?.closest?.("[data-ga][data-p]");
const type = gaBtn?.getAttribute("data-ga");
const pid  = gaBtn?.getAttribute("data-p");
if (type && pid){
  e.preventDefault();
  e.stopPropagation();

  const s = getActiveSession();
  if (!s) return;
  if (!quickTeamsCache) return;

  const cell = ensureSessionGA(s, pid);
  if (type === "G") cell.g += 1;
  if (type === "A") cell.a += 1;
  recomputeAllStatsFromSessions();
renderTable();

  save();
  pushStateToCloud();

  renderSessionGASummary(); // atjauno tikai rindiÅ†u
  return;
} 
  
  // NEAIZTIEC form elementus (citÄdi pÄrzÄ«mÄ“Å¡ana/handleri var noraut fokusu)
  const t = e.target;
  const tag = t?.tagName;
  if (tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA" || tag === "OPTION") return
  // DzÄ“st spÄ“lÄ“tÄju
  const del = e.target?.getAttribute?.("data-del");
  if (del) { deletePlayer(del); return; }

  // AtvÄ“rt sesiju
  const setactive = e.target?.getAttribute?.("data-setactive");
  if (setactive) { setActiveSession(setactive); return; }

  // DzÄ“st sesiju
  const dels = e.target?.getAttribute?.("data-delsession");
  if (dels){
    if (!confirm("DzÄ“st sesiju? (Tiks pÄrrÄ“Ä·inÄta statistika.)")) return;
    deleteSession(dels);
    return;
  }

  // Pick my player (strÄdÄ abÄm pogÄm)
  const pickBtn = e.target?.closest?.('[data-pickme="1"]');
  if (pickBtn){
    if (!state.players.length) return alert("Nav spÄ“lÄ“tÄju.");
    const names = state.players.map(p => p.name).join("\n");
    const chosen = prompt("Ieraksti savu vÄrdu tieÅ¡i kÄ sarakstÄ:\n\n" + names);
    if (!chosen) return;

    const p = state.players.find(x => x.name.toLowerCase() === chosen.trim().toLowerCase());
    if (!p) return alert("VÄrds nav atrasts.");

    myPlayerId = p.id;
    localStorage.setItem("myPlayerId", myPlayerId);

    // ONLINE: piesaista arÄ« Firestore, citÄdi onSnapshot pÄ“c brÄ«Å¾a pÄrraksta atpakaÄ¼ uz null
    if (onlineEnabled && fb && myUid){
      selfSetMyPlayer(myPlayerId);
    }
  }
    renderAll();
    return;
    
    // Become admin (works everywhere)
const adminBtn = e.target?.closest?.("#becomeAdmin, #becomeAdminList");
if (adminBtn) {
  if (!onlineEnabled || !fb) return alert("Online nav pieejams.");
  (async () => {
    try {
      const ref = adminDoc();
      const snap = await fb.getDoc(ref);
      const d = snap.data() || {};
      if (d.adminUid && d.adminUid !== myUid) return alert("Admins jau ir iestatÄ«ts.");
      await fb.setDoc(ref, { adminUid: myUid, createdAt: fb.serverTimestamp() }, { merge: true });
      alert("Tu tagad esi admins âœ…");
      renderAll();
    } catch (e) {
      alert("Admin kÄ¼Å«da: " + e.message);
    }
  })();
  return;
}
});

  // --- Table ---
  function renderTable() {
    const sorted = [...state.players].sort((p,q) => {
      if ((q.elo||0) !== (p.elo||0)) return (q.elo||0) - (p.elo||0);
      const wp = p.games ? p.wins/p.games : 0;
      const wq = q.games ? q.wins/q.games : 0;
      if (wq !== wp) return wq - wp;
      return (q.sessions||0) - (p.sessions||0);
    });

    const rows = sorted.map((p,i) => {
      const wp = p.games ? (100*p.wins/p.games) : 0;
      const pts = (p.g||0) + (p.a||0);
      return `<tr>
        <td>${i+1}</td>
        <td>${escapeHtml(p.name)}</td>
        <td>${p.sessions||0}</td>
        <td>${p.games||0}</td>
        <td>${p.wins||0}</td>
        <td>${wp.toFixed(1)}%</td>
        <td class="mono">${Math.round(p.elo||1000)}</td>
        <td>${p.g||0}</td>
        <td>${p.a||0}</td>
        <td>${pts}</td>
      </tr>`;
    }).join("");
    el("table").querySelector("tbody").innerHTML = rows || `<tr><td colspan="10" class="muted">Nav datu.</td></tr>`;
  }

  // --- Export / Import ---
  function exportJSON() {
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "dika-hokeja-sezona.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function importJSON(file) {
    const r = new FileReader();
    r.onload = () => {
      try {
        const obj = JSON.parse(r.result);
        if (!obj.players || !obj.sessions) throw new Error("Nepareizs fails.");
        localStorage.setItem(KEY, JSON.stringify(obj));
        location.reload();
      } catch(e) {
        alert("Importa kÄ¼Å«da: " + e.message);
      }
    };
    r.readAsText(file);
  }

  function resetAll() {
    if (!confirm("TieÅ¡Äm notÄ«rÄ«t visu sezonu?")) return;
    localStorage.removeItem(KEY);
    location.reload();
  }

  // --- Render all ---
  function renderAll() {
    renderPlayers();
    renderSessionsList();
    renderActiveSession();
    renderTable();
  }

  // --- Wire top-level events ---
  el("addPlayer").onclick = () => { addPlayer(el("playerName").value); el("playerName").value=""; el("playerName").focus(); };
  el("playerName").addEventListener("keydown", (e) => { if (e.key === "Enter") el("addPlayer").click(); });

  el("createSession").onclick = () => {
    createSession(el("sessionDate").value);
    el("sessionDate").value = "";
  };

  el("exportBtn").onclick = exportJSON;
  el("importFile").onchange = (e) => { if (e.target.files?.[0]) importJSON(e.target.files[0]); };

  el("resetAll").onclick = resetAll;

  // Initial render
  renderAll();
let firebaseInited = false;

// Firebase init: RUN ONCE (nevis ik pÄ“c 200ms)
let _fbInited = false;
(function waitForFirebase(){
  if (_fbInited) return;
  if (!window.firebaseCtx) return setTimeout(waitForFirebase, 200);

  _fbInited = true;
  fb = window.firebaseCtx;
  onlineEnabled = true;
  initOnlineIfPossible();
})();

</script>
</body>
</html>
